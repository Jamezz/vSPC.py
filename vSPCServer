#!/usr/bin/env python

# Copyright 2011 Kevan A. Carstensen. All Rights Reserved
# Adapted from code written by Zach M. Loafman, copyright 2011 Isilon Systems.
#
# Redistribution and use in source and binary forms, with or without modification, are
# permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright notice, this list of
#       conditions and the following disclaimer.
#
#    2. Redistributions in binary form must reproduce the above copyright notice, this list
#       of conditions and the following disclaimer in the documentation and/or other materials
#       provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY California State Polytechnic University, Pomona.
# ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import logging
import os
import socket
import sys

from vSPC import vSPC, get_backend_type

# Default for --proxy-port, the port to send VMs to.
PROXY_PORT = 13370

# Default for --admin-port, the port to hit vSPC-query with
ADMIN_PORT = 13371

# Default for --port-range-start, start of port range to assign VMs.
# Ports may be reallocated within the range, based on active connections
# and --expire.
VM_PORT_START = 50000

# Default for --expire, number of seconds a VM (based on uuid) holds a
# port number / listener open with no VMware or client connections
VM_EXPIRE_TIME = 24*3600

BASENAME="vSPCServer"
__revision__="3"

def daemonize():
    '''
    Daemonize, based on http://code.activestate.com/recipes/278731-creating-a-daemon-the-python-way/
    '''

    pid = os.fork()
    if pid:
        os._exit(0) # Parent exits
    os.setsid() # Become session leader
    pid = os.fork() # Re-fork
    if pid:
        os._exit(0) # Child exits

    # We are daemonized grandchild, reset some process state
    os.chdir('/')
    os.umask(0)

def usage():
    sys.stderr.write('''\
%s (%s)

Common options:
%s: [-h|--help] [-d|--debug] [-a|--admin-port P]

  Additional options:
    [-p|--proxy-port P] [-r|--port-range-start P] [--vm-expire-time seconds]
    [--backend Backend] [--backend-args 'arg string'] [--backend-help]
    [-f|--persist-file file] [--pidfile file]
    [--stdout] [--no-fork]

  Start Virtual Serial Port Concentrator. By default, vSPC listens on
  port %s for VMware virtual serial connections. Each new VM is
  assigned a listener, starting at port %s.

  In order to configure a VM to use the vSPC, you must be running ESXi 4.1+.
  Add the serial port to the VM, then select:
    (*) Use Network
      (*) Server
      Port URI: %s
      [X] Use Virtual Serial Port Concentrator:
      vSPC: telnet://%s:%s
  NOTE: Direction MUST be Server, and Port URI MUST be %s

  Virtual serial ports support TLS/SSL on connections to a concentrator.
  To use TLS/SSL, configure the serial port as above, except for the
  vSPC URI field, which should say:
      vSPC URI: telnets://%s:%s
  then launch vSPC.py with the --ssl, --cert, and --key (if necessary)
  options.

  To have the process id of the server written to a file, use the
  --pidfile argument. This is useful for initscripts and other process
  management tools.

  %s makes a best effort to keep VM to port number mappings stable,
  based on the UUID of the connecting VM. Even if a VM disconnects,
  client connections are maintained in anticipation of the VM
  reconnecting (e.g. if the VM is rebooting). The UUID<->port mapping
  is maintained as long as there are either client connections or as
  long as the VM is connected, and even after this condition is no
  longer met, the mapping is retained for --vm-expire-time seconds
  (default %s).

  The backend of %s serves three major purposes: (a) On initial load,
  all port mappings are retrieved from the backend. The main thread
  maintains the port mappings after initial load, but the backend is
  responsible for setting the initial map. (This design was chosen to
  avoid blocking on the backend when a new VM connects.) (b) The
  backend serves all admin connections (because it has full knowledge
  of the mappings), (c) The backend can fire off customizable hooks as
  VMs come and go, allowing for persistence, or database tracking, or
  whatever.

  By default, %s uses the "Memory" backend, which really just
  means that no initial mappings are loaded on startup and all state
  is retained in memory alone. The other builtin backend is the "File"
  backend, which can be configured like so:
    --backend File --backend-args '-f /tmp/vSPC'.
  As a convenience, this same configuration can be accomplished using
  the top level parameter -f or --persist-file, i.e. '-f /tmp/vSPC' is
  synonymous with the previous set of arguments.

  If '--backend Foo' is given but no builtin backend Foo exists, %s
  tries to import module vSPCBackendFoo, looking for class vSPCBackendFoo.
  See --backend-help for programming details.

  Explanation of server options:
    -a|--admin-port: The port to listen/use for queries (default %s)
    -p|--proxy-port: The proxy port to listen on (default %s)
    -r|--port-range-start: What port to start port allocations from (default %s)
    --vm-expire-time: How long to wait before expiring a mapping with no connections
    -f|--persist-file: DBM file prefix to persist mappings to (.dat/.dir may follow)
    --backend: Name of custom backend class (see above)
    --backend-args: Arguments to custom backend
    --stdout: Log to stdout instead of syslog
    --ssl: Start SSL/TLS on connections to the proxy port
    --cert: The certificate or PEM file to use on the proxy port. Only meaningful with --ssl
    --key: The key, if necessary, to the certificate given by --cert. Only meaningful with --ssl
    --no-fork: Don't daemonize
    --pidfile: The file to write the process ID of the server to (no file by default)
    -d|--debug: Debug mode (turns up logging and implies --stdout --no-fork)
''' % (BASENAME, __revision__, BASENAME, ADMIN_PORT, PROXY_PORT,
       VM_PORT_START, BASENAME, BASENAME, BASENAME,
       socket.gethostname(), PROXY_PORT, BASENAME, socket.gethostname(), PROXY_PORT,
       BASENAME, VM_EXPIRE_TIME, BASENAME, BASENAME, BASENAME,
       ADMIN_PORT, PROXY_PORT, VM_PORT_START))

if __name__=="__main__":
    import getopt

    proxy_port = PROXY_PORT
    admin_port = ADMIN_PORT
    vm_port_start = VM_PORT_START
    vm_expire_time = VM_EXPIRE_TIME
    debug = False
    syslog = True
    fork = True
    backend_type_name = 'Memory'
    backend_args = ''
    use_ssl = False
    ssl_cert = None
    ssl_key = None
    pidfile = None

    try:
        opts, args = getopt.gnu_getopt(sys.argv[1:], 'a:f:hdp:r:',
                                       ['help', 'debug', 'admin-port=',
                                        'proxy-port=', 'port-range-start=',
                                        'stdout', 'no-fork', 'ssl',
                                        'vm-expire-time=', "cert=", "key=",
                                        'backend=', 'backend-args=',
                                        'backend-help', "no-vm-ports",
                                        'persist-file=', 'pidfile='])
        for o,a in opts:
            if o in ['-h', '--help']:
                usage()
                sys.exit(0)
            elif o in ['-d', '--debug']:
                debug = True
                syslog = False
                fork = False
            elif o in ['-a', '--admin-port']:
                admin_port = int(a)
            elif o in ['-p', '--proxy-port']:
                proxy_port = int(a)
            elif o in ['-r', '--port-range-start']:
                vm_port_start = int(a)
            elif o in ['--vm-expire-time']:
                vm_expire_time = int(a)
            elif o in ['--stdout']:
                syslog = False
            elif o in ['--no-fork']:
                fork = False
            elif o in ['--backend']:
                backend_type_name = a
            elif o in ['--backend-args']:
                backend_args = a
            elif o in ['--backend-help']:
                help(vSPCBackendMemory)
                sys.exit(0)
            elif o in ['-f', '--persist-file']:
                import pipes
                backend_type_name = 'File'
                backend_args = '-f %s' % pipes.quote(a)
            elif o in ['--ssl']:
                use_ssl = True
            elif o in ['--cert']:
                ssl_cert = a
            elif o in ['--key']:
                ssl_key = a
            elif o in ['--pidfile']:
                pidfile = a
            elif o in ['--no-vm-ports']:
                vm_port_start = None
            else:
                assert False, 'unhandled option'
    except getopt.GetoptError, err:
        print str(err)
        usage()
        sys.exit(2)

    logger = logging.getLogger('')
    logger.setLevel(logging.DEBUG if debug else logging.INFO)
    if syslog:
        from logging.handlers import SysLogHandler
        from logging import Formatter
        formatter = Formatter(fmt="vSPC.py[%(process)d]: %(message)s")
        handler = SysLogHandler(address="/dev/log")
        handler.setFormatter(formatter)
        logger.addHandler(handler)

    if len(args) > 0:
        print "Unexpected arguments: %s" % args
        usage()
        sys.exit(2)

    if use_ssl and not ssl_cert:
        print "Must specify certificate in order to use SSL"
        usage()
        sys.exit(2)

    backend = get_backend_type(backend_type_name)()
    backend.setup(backend_args)

    if fork:
        daemonize()
        if pidfile is not None:
            f = open(pidfile, "w")
            f.write("%d" % os.getpid())
            f.close()

    try:
        backend.start()

        vSPC(proxy_port, admin_port, vm_port_start, vm_expire_time, backend, use_ssl, ssl_cert, ssl_key).run()
    except KeyboardInterrupt:
        logging.info("Shutdown requested on keyboard, exiting")
        sys.exit(0)
    except Exception, e:
        logging.exception("Top level exception caught")
        sys.exit(1)
